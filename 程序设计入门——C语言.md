## 程序设计入门——C语言

**翁恺**

### 第一章：程序设计与C语言

#### 1.计算机和编程语言

**课程目的**

​		通过学习编程，来理解计算机是怎样解决问题的。

**人和计算机的区别**

​		人：What to do

​		计算机：How to do

​		重复是计算机最擅长的事情

​		程序设计语言必须具有**数据表达**和**数据处理(称为控制)**的能力，程序设计语言的3个基本内容——数据表达、运算和流程控制

**程序的执行**

​		解释：借助一个程序，那个程序能试图理解你的程序， 然后按照你的要求执行 

​		编译：借助一个程序，就像一个翻译，把你的程序翻译成计算机真正能懂的语言——机器语言——写的程序，然后，这个机器语言写的程序就能直接执行了

**解释语言vs编译语言**

​		语言本无编译/解释之分，只是常用的执行方式而已

​		解释型语言有特殊的计算能力(比如计算中修改代码)

​		编译型语言有确定的运算性能

**课后讨论1.1.1：关于编程语言和计算机**

> ​		计算机里的CPU可以直接运行人类编写的程序吗？为什么说编程语言不是和计算机交谈的语言。
>

​		答：不能，因为cpu可以直接识别的是机器语言，而编程语言要经过转换才能形成0101的机器语言，所以不能直接运行；编程语言是要求计算机做事情，是要求，而不是交谈，交谈是我点开了一个app，他能给我显现个内容（这也是交互性吧）

**课后讨论1.1.2：编译执行与解释执行**

> ​		有的编程语言，源代码经过编译后形成目标代码，但是这样的目标代码不能直接在CPU上执行，而是需要由一个仿真器程序来解释执行。这样的执行方式是编译的还是解释的？
>

​		答：判断是解释执行还是编译执行最根本的方法是判断是否产生可直接运行的机器代码。编译执行的步骤，一般包括：编译、链接和执行。在编译、链接后，会产生可直接运行的机器代码。在产生机器代码之后，可以单独运行执行（VC中的！，DEV—C＋＋中的F10）程序即可重复运行。不需要再次编译和链接。在本题中，目标代码必须要仿真器程序才能得到再次执行，说明在执行过程中没有产生并保存机器代码。仿真器程序的本质还是对目标代码进行逐条解释，并执行。所以，认为是解释执行的。

#### 2.C语言

**为什么历史选择了C**

​		单片机、操作系统等等很多地方都往往用C来编写。而Java等语言有很多可以替代的语言。

​		现代的编程语言在语法上的差异很小

​		几乎都是C-like语言，语言的能力和适用领域主要是由库和传统决定的

​		C语言起源于1969年夏天，“It was the summer of '69'”

**C语言的发展**

​		C语言是从B语言发展而来的，B语言是从BCPL发展而来的，BCPL是从 FORTRAN发展而来的

​		BCPL和B都支持**指针间接方式**，所以C也支持了

​		C语言还受到了PL/1的影响，还和PDP-11的机器语言有很大的关系

​		1973年3月，第三版的Unix上出现了C语言的编译器

​		1973年11月，第四版的Unix（System Four）发布了，这个版本是完全用C语言重新写的

**C的发展与版本**

​		经典教材：K&R the C

​		The C Programming Language, by Brian Kernighan and Dennis Ritchie, 2nd Edition, Prentice Hall

**C的发展与版本-标准**

​		1989 —— ANSI C

​		1990 —— ISO接受了ANSI的标准 C89

​		1995和1999两次更新，分别为C95和C99

​		所有当代的编译器都支持C99标准了

**C语言用在哪里**

​		操作系统 

​		嵌入式系统

​		驱动程序

​		底层驱动

​		图形引擎、图像处理、声音效果

**C语言是一种工业语言**

​		开发效率>>学习过程

​		开发效率>>开发乐趣

​		日常应用很少直接用C语言编写

​		学习C的过程主要是写练习代码而非真实软件

**结构化程序**

​		结构化程序由三种基本结构组成，三种基本结构组成的算法<u>可以完成任何复杂的任务</u>。

​		结构化程序的设计方法：a.自顶向下 b.逐步求精 c.模块化 d.结构化

**C语言需要编译运行**

​		所以你需要编译器、编辑器或者IDE(Integrated Development Environment)集成开发环境

​		推荐的编译器——Dev C++(可以在代码托管网站——soureceforge.net上下载)

​		C语言的编译器很多，因为早期为其配置编译器的厂家很多，所以会导致很多个人因素夹杂其中的“方言”

​		后面很多语言，为其做编译器的厂商往往只掌握在少数厂商手上，反而容易选了:)

**C语言的编辑-编译-连接**

​		C语言编写的程序称为**源程序**，它以ASCII代码形式存放在一个文本文件中，NotePad++,Source Insight，Visual Studio Code是常用的文本代码编辑器，该文件一般以“**.c**”作为文件扩展名。

​		编译是指将已经编辑好的源程序编译成二进制代码表示的**目标程序**的过程。编译分为预处理和编译处理，如果存在语法错误，编译程序会指出语法错误所在，不会生成二进制代码，没有语法错误则生成一个二进制文件，后缀为"**.obj**"。

​		上述过程产生的文件还不能直接运行，还需要编程环境提供的库函数进行连接(Link)，形成**可执行的程序**，是一个二进制机器指令文件，后缀为“**.exe**”。

​		源程序中的每条可执行语句最终都将被转换成二进制机器指令，而像注释这样的非执行语句将会在编译时就被忽略。

![1.0.drawio](笔记插图/1.0.drawio.png)

<center style="color:#C0C0C0">图1.0 编辑-编译-连接</center>

#### 3.第一个C程序

**程序框架**

```c
#include<stdio.h>

int main()
{
 	/*Code*/
    return 0;
}
```

​		C语言规定必须用main作为主函数名，程序将从此开始执行，在此结束，一个C源程序至少应包含一个main()函数。

​		C程序的基本组成单位是<u>语句</u>。

​		C程序中，{ }括起的许多语句成为<u>复合</u>语句。

**输出 `printf()`**

```c
printf("Hello World!\n");
```

​		①""里面的叫字符串，`printf()`会将其中的内容原封不动的输出。

​		②如果需要在最终黑色的控制台调整输出内容，可以加入转义字符，比如'\n'

​			\n表示需要在输出结果后面换一行

​		③后面可以插入表达式做运算

```c
printf("%d\n", 20 + 25);
```

​		④C程序实现的算法可以没有输入，但是必须要有输出(没输出这个程序有什么意义呢?)

​		⑤保留2位小数，以及保留2位，以及补零。

```c
printf("%m.nf", x);  //m为宽度限定词，意为保留宽度m，不足m则左端补空格，大于m则按实际输出; 小数点后n位。
printf("%.2f", x);   //保留两位小数
printf("%2f", x);    //保留两位宽度
printf("%02f", x);   //保留两位宽度，不足前面补零
```

**程序中的错误**

​		C语言的代码可以写在不同的两行，是符合语法的。

​		编译的时候发现的错误所在的地方会以红色的底表示出来 (Dev-C++为例)

​		具体的错误原因以英文列在下方的窗口里

​		C的编译器给出的错误提示往往不那么好“猜”

​		不要用中文，C编译器只能识别半角的英文符号

​		关于数字0，为了防止和英文字母O混淆，编译器往往在0的中间加点或者斜线区分，这个是有一定历史渊源的

​		调试是在程序中查找错误并修改错误的过程。(错误包括<u>逻辑错误(语义错误)</u>和<u>语法错误</u>)

​		有时调试可以不借助编译器的调试工具，而是在程序某些节点插入printf()，把值直接打印出来观察是否有异常。

**关于GCC**

​		C编译器最早是机器自带的，cc指的是Compile Collection(*编译器生成器*)

​		gcc就是GNU操作系统下的CC，后来GNU的编译器打败了Unix自己做的编译器，于是很多Unix机器也开始使用GCC，90年代，GCC也跑在Linux上

​		同样，DOS(Disk Operating System)磁盘操作系统上，最早使用的是mscc(微软的cc)，也就是后来VS 6、VS20xx的前身。

**那么如何移植GCC到个人计算机的主流系统Windows上呢？**

①移植gcc本身

​	gcc→API(应用程序接口)→windows

②移植library库

![1.1.drawio](笔记插图/1.1.drawio.png)

<center style="color:#C0C0C0">图1.1 连接的过程</center>

如何移植library有两种方案

a.使用Cygwin(一个在Windows平台上运行的类UNIX模拟环境)

​		在Windows上给一个Unix Lib.，Cygwin下gcc编译的.c文件在和Unix lib.共同努力下，变成一个可以在Windows上运行的Unix程序

![1.2.drawio](笔记插图/1.2.drawio.png)

<center style="color:#C0C0C0">图1.2 利用Cygwin移植library</center>

​		可以知道，Cygwin底下的gcc编译出的程序，不是在Windows上直接运行的，而是在Unix上可以直接运行的，但Cygwin给了一个可以在windows上运行Unix程序的接口，于是你的程序就可以运行了。

b.使用MinGW(Minimalist GNU for Windows——Windows上可以跑的最小GNU的集合)

​		它是一个可自由使用和自由发布的Windows特定头文件和使用GNU工具集导入库的集合，允许你在GNU/Linux和Windows平台生成本地的Windows程序而不需要第三方C运行时（C Runtime）库。目前已经停更很多年了，原来版本是MinGW32，现在最新的是MinGW64。另外，现在也有其它选择——<u>TDM-GCC</u>，这是衍生自 MinGW 和 MinGW-w64 的类似项目，但是由另外的机构开发的，分为 32 位与 64 位两个版本，32 位版本的编译目标仅兼容 32 位应用程序，此外，MinGW-w64 还有基于 <u>LLVM 构建的 Clang</u> 编译器。TDM-GCC安装较为简单，所以可以优先选用。

​		MinGW(读音“民基W”，不要读成“明W”)，MinGW的做法如下

![1.3.drawio](笔记插图/1.3.drawio.png)

<center style="color:#C0C0C0">图1.3 利用MinGW移植library</center>

​		MinGW和Cygwin的区别是，MinGW用GNU编译出Windows下可以运行的程序，而Cygwin编写的是Unix可以直接运行的程序。

**GCC下载与安装**

TDM-GCC官网：tdm-gcc.tdragon.net

Visual Studio Code官网：code.visualstudio.com

​		注意，Visual Studio是一个编辑器，一开始是不能直接运行C/C++程序的，应该使用拓展插件。

​		下载**C/C++** 语法高亮*、***Code Runner**两个插件就可以

​		多个.c文件处理就比较复杂，Visual Studio肯定不只是用来解决一个.c文件的处理，多文件处理应该使用**Work Space(工作区)**，Work space建立方式不能直接建立，而是通过**新建文件夹→Open Folder**来建立。

**Work Space的使用**

​		①如果工作区初始完全为空，则通过new file建立文件

​		②如果工作区初始非空，VS会自动识别文件夹内的工程文件，并显示在左侧边文件预览栏内，但此时不能直接Run我们想要运行的第一个.c文件，会显示编译不成功。因为VS只能认当前那第一个.c文件内的代码，其他使用到的work space里的其他库文件没有成功编译进去。解决方法有两个：

​		a.使用View下的Terminal(终端)

​		在Terminal内编译需要的其他.c文件，将这些文件一起编译。
​		b.使用Make file.

​		把make file拷贝到目录下，在terminal内，使用自带的mingw32-make，通过make把这些.c文件合并为一个大文件。

**课后讨论1.3.1：我们是在学习GCC吗？**

> ​		常听到有人说他学的是Visual C，有人学的是Turbo C，不是我们学的什么Dev C，是他们的比我们的高级吗？还有GCC到底是什么？

​	答：

​		1、Visual C、Turbo C和Dev C都是C语言的开发工具，Visual C是由微软公司开发维护C/C++的开发工具（1993年首次推出），Turbo C由美国Borland公司开发的一套C语言开发工具，它出现最早，于1987年首次推出，Dev C由个人开发者Colin Laplace主导开发维护，目前已经不再更新维护，而包含Visual C的Visual Studio一直在更新，但是Visual Studio非常庞大，如果需要轻量的编译工具，推荐Code Blocks。当然，Code Blocks与上述这些工具没有本质上的区别。

​		C语言可移植性体现在不依赖具体实现，也就是说在Visual C下成功编译并执行的代码，用Turbo C和Dev C也能编译并成功执行，而且功能一致。这些工具之间的区别在于其所提供的代码编辑功能等有差异，比如有些工具不支持代码高亮或C语言关键字着色等等。当然，也有相似功能但操作方式不一样的情况，比如调试功能的操作方式。

​		2、GCC原名为GNU C Compile，原本只能处理C语言，后来发展成为Fortran、Pascal、Objective-C、Java、Ada,Go等多种语言的编译器，便改名为GNU Compiler Collection。

**课后讨论1.3.2：main()的样子**

> ​		为什么看到有的书上的`main()`是`void main()`，而我们课件上是`int main()`？还有`main()`里面那句`return 0`; 是必须的吗？
>

答：

​		main函数的返回值用于说明程序的退出状态。如果返回0，则代表程序正常退出。返回其它数字的含义则由系统决定。通常，返回非零代表程序异常退出。

1.void main（）

​		有一些书上的，都使用了void main( ) ，其实这是错误的。C/C++ 中从来没有定义过`void main( ) `。C++ 之父 Bjarne Stroustrup 在他的主页上的 FAQ 中明确地写着 “The definition void main( ) { /* … */ } is not and never has been C++, nor has it even been C.”

　　这可能是因为 在 C 和 C++ 中，不接收任何参数也不返回任何信息的函数原型为“void foo(void);”。可能正是因为这个，所以很多人都误认为如果不需要程序返回值时可以把main函数定义成void main(void) 。然而这是错误的！main 函数的返回值应该定义为 int 类型，C 和 C++ 标准中都是这样规定的。虽然在一些编译器中，void main（） 可以通过编译，但并非所有编译器都支持 `void main（）` ，因为标准中从来没有定义过 void main 。g++3.2 中如果 main 函数的返回值不是 int 类型，就根本通不过编译。而 gcc3.2 则会发出警告。所以，为了程序拥有很好的可移植性，一定要用` int main （）`。

2.main（）

​		那既然main函数只有一种返回值类型，那么是不是可以不写？规定：不明确标明返回值的，默认返回值为int，也就是说 main()等同于`int main()`，而不是等同于`void main()`。在C99中，标准要求编译器至少给` main() `这种用法来个警告，而在c98中这种写法是被允许的。但为了程序的规范性和可读性，还是应该明确的指出返回值的类型。

**章末习题：Hello World”（5分）**

> **题目内容：**
>
> 请输出一行，内容为
>
> Hello World
>
> 请注意大小写。
>
> 由于这一周只是简单地介绍了C程序的基本框架，还不能做很多事情，甚至还不能做数据的输入，所以这一周的题目也非常简单。第二周会仔细介绍如何在中M和拼题A做题，如果你一时无法搞定如何提交这周的作业，没关系，可以先在在线编程环境或IDE中做好程序，下周学过之后再来提交作业。。所以，你可以慢慢来，一点点能跟上来就可以了。
>
> **输入格式:**
>
> 无输入
>
> **输出格式：**
>
> 一行文字
>
> **输入样例：**
>
> 无
>
> **输出样例：**
>
> Hello World
>

---

```c
#include<stdio.h>

int main()
{
    printf("Hello World");
    
    return 0;
}
```



### 第二章：计算

#### 1.变量

```c
#include <stdio.h>

int main()
{
	const int AMOUNT = 100;           /*Line 1*/
	int price = 0;					/*Line 2*/

	printf("请输入金额（元）：");
	scanf("%d", &price);

	int change = AMOUNT - price;

	printf("找您%d元。\n", change);

	return 0;
}
```

​		受到之前`printf()`做计算的启发，我们想到能否不要每次都输入`printf()`，而是只给两个数字就能计算呢？这就要利用到变量来实现了。

**变量的设想与定义**

​		我们需要：1.有地方放输入的数字 2.有办法输入数字 3.输入的数字能参与计算

​		上述程序`int price = 0`，定义了一个变量，变量的名字是price，类型是int，初始值是0。

​		变量就是一个保存数据的地方，只有用变量保存了数据，这个数据才能参与到后面的运算中去。

​		变量定义的一般形式是：<类型名称><变量名称>

​		变量需要一个名称，变量的名字就是一种“标识符”

​		标识符有标识符的构造规则，基本规则是只能由**下划线、字母、数字**组成，数字不能出现在第一个位置上，C语言的<u>关键字</u>(或叫<u>保留字</u>)，不可用做标识符。

**如何输入**

​		a.输入也在终端窗口中。

​		b.输入是以行为单位进行的，行结束标志就是你按下回车键，在你按下回车键之前程序不会读到任何内容。

​		c.C语言中，数据的输入和输出都是通过函数调用实现的。

**变量的赋值和初始化**

​		`int price = 0`除了定义了一个新变量，还是一个赋值语句，"="表示将右边的值赋值给左边的变量。因为这个语句是在定义变量时赋值，所以又称为**初始化**。对C语言来说，赋值和初始化差异并不大，但对其他语言两者差异可能会比较大。

```c
<类型名称><变量名称> = <初始值>  /*初始化操作*/
```

​		注意，一行如果有多个变量要初始化，你必须一个一个赋值，而不能只赋给一个，那样其他变量值不确定。

​		赋值与数学不同，a=b在数学中表示关系，即a、b的值一样，但在C语言中表示动作，把b的值赋给a。关系是静态的，动作是动态的，前者a=b和b=a是等价的，但后者意义却截然相反。

​		C语言不强制要求所有变量都在定义的地方做初始化，但是所有变量在第一次被使用(出现在赋值运算符的右侧)之前，应该被赋值一次。

​		赋值“=”也是运算符，有运算符的式子就叫**表达式**。

**变量类型**

​		C是一种有类型的语言，所有变量在使用之前必须定义或声明，所有的变量必须有确定的数据类型。数据类型表示变量可以存放什么样的数据，变量中也只能存放指定类型的数据，程序运行过程中也不能改变变量类型。

​		ANSI C只能在开头定义变量，C99支持任何要使用时定义变量即可。

**scanf()**

```c
	scanf("%d", &price);
	scanf("%d %d", &a, &b);
	scanf("%d,%d", &a, &b);
```

​		`scanf()`是C语言中的一个输入函数,用于从标准输入设备(通常是键盘)读取数据。**它的全称是“scan formatted”**,表示按照指定的格式扫描输入数据。

​		a.要求这个函数读入下一个整数，读到的结果赋值给变量price。

​		b.小心price前面的&

​		c.特别注意，`scanf()`两个双引号之间，是你要输入的内容，而不是它会展示的内容，比如中间如果有逗号，你两个整数输入中间也要输入逗号，如果格式控制符是连续的，你也必须连续输入，`scanf()`才能正确运行，。

​		d.`scanf()`可以读多个变量

​		e.如果格式控制符和变量类型不对应，比如double类型用了%f输入，则`scanf()`会输出0。

```C
#include <stdio.h>

int main()
{
	int a;
	int b;

	printf("请输入两个整数：");
	scanf("%d %d", &a, &b);
	printf("%d + %d = %d\n", a, b, a + b);

	return 0;
}
```



**常量**

```c
int change = 100 - price;
const int AMOUNT = 100;    //更好的方式
```

​		固定不变的数，是常数。直接写在程序里，我们称作直接量(literal)。

​		更好的方式，是定义一个常量，如上面第二行代码。

​		我们把出现在程序里面莫名其妙的数字叫Magic Number

**const**

​		const是一个修饰符，加在int的前面，用来给这个变量加上一个const(不变的)属性。这个const属性表示这个变量只要初始化了，就不能再修改了。一般用全大写字母突出强调该变量是const变量。

```c
int change = AMOUNT -price;
```

​		如果你试图对常量做修改，把它放在赋值运算符的左边，编译器会报错。

```c
[Error] assignment of read-only variable 'a'
```

​		如果我们想让用户输入AMOUNT初始值，而不是使用固定初始值，可以使用下述代码。

```c
	int amount = 100;           /*给个初值没问题*/
	int price = 0;

	printf("请输入金额（元）：");
	scanf("%d", &price);

	printf("请输入票面（元）：");
	scanf("%d", &amount);

	int change = amount - price;

	printf("找您%d元。\n", change);
```



#### 2.计算

```c
#include <stdio.h>

int main()
{
	printf("请分别输入身高的英尺和英寸，"
		"如输入\"5 7\"表示5英尺7英寸：");

	double foot;
	double inch;

	scanf("%lf %lf", &foot, &inch);

	printf("身高是%f米。\n", 
		((foot + inch / 12) * 0.3048));

	return 0;
}
```

**C语言世界的数字运算**

​		两个整数的运算结果只能是整数

​		10/3*3 = 9

​		10和10.0在C中是完全不同的数

​		10.0是浮点数

**浮点数**

​		带小数点的数值。浮点意思就是这个数小数点是可以浮动的，是计算机内部表达数字的一种方式，另一种方式叫**定点数**。不过C语言中你不会遇到定点数，人们借用浮点数这个词来表达所有带小数点的数。

​		但整数和浮点数放在一起运算时，C语言会将整数转换为浮点数，然后进行浮点数的运算。

​		根据上一条，我们发现只要把其中一个变量设为浮点数并参与运算，表达式的结果就会转换为浮点数了，但需要注意，将整型变量赋值`sum = 0.5;`sum的结果依然为0。

```c
//执行以下程序段，sum的值是1。
int i, sum;
sum = 0;
for (i = 1; i <= 2; i++){
    sum = sum + 1.0/i;
}
//执行以下程序段，sum的值是0。
int i;
double sum;
sum = 0;
for (i = 2; i <= 4; i = i + 2){
    sum = sum + 1/i;
}
```

**double**

​		double的意思是“双”，它本来是“双精度浮点数”的第一个单词，人们用来表示浮点数类型。除了double，还有float，表示单精度浮点数。

​		double类型的变量，`scanf()`和`printf()`函数都需要更改相应格式控制符。

```c
int a; float b; double c;
scanf("%d", &a); printf("%d", a);
scanf("%f", &b); printf("%f", b);
scanf("%ld", &c); printf("%f", c);
```

**整数**

​		数据类型不能表达小数部分的数，整数和整数的运算结果还是整数。

​		计算机里面会有纯粹的整数，因为它运算快，占空间小。而现实生活中也在大量做整数的运算，所以整数的作用还是很大的。

#### 3.表达式

​		**表达式**是一切运算符运算符和算子的组合，用来计算一个值。

```c
total = 57;
count = count + 1;    //注意，count 和 赋值运算符 和 右边的count + 1一起构成表达式。
```

**运算符&算子、取余运算**

​		运算符（operator）是指进行运算的动作，比如加法运算符“+”，减法运算符“-”；

​		算子（operand）是指参与运算的值(也可以称为操作数)，这个值可能是常数，也可能是变量，还可能是一个方法的返回值。

​		取余运算就是求两个整数相除后的余数，用A%B来表示。C语言中，求余运算符两边，必须为整型数。

​		`x % n`的结果是[0，n - 1]的一个整数。

**计算时间差**

​		如果直接分别减，有可能会出现分钟借位的情况，所以要有所处理。

```c
int hour1, minute1;
int hour2, minute2;

scanf("%d %d", &hour1, &minute1);
scanf("%d %d", &hour2, &minute2);

int t1 = hour1 * 60 + minute1;    //转换为分钟单位
int t2 = hour2 * 60 + minute2;

int t = t2 - t1;

printf("时间差是%时%分。", t/60, t%60);  //t÷60小时部分 t%60分钟部分
```

**运算符优先级**

```c
//求平均值
#include <stdio.h>

int main()
{
	int a,b;

	scanf("%d %d", &a, &b);

	double c = (a+b)/2.0;
	
	printf("%d和%d的平均值=%f\n", a, b, c);

	return 0;
}
```

| 优先级 | 运算符 |   运算   | 结合关系 | 举例  |
| :----: | :----: | :------: | :------: | :---: |
|   1    |   +    | 单目不变 | 自右向左 | a* +b |
|   1    |   -    | 单目取负 | 自右向左 | a* -b |
|   2    |   *    |    乘    | 自左向右 | a * b |
|   2    |   /    |    除    | 自左向右 | a / b |
|   2    |   %    |   取余   | 自左向右 | a % b |
|   3    |   +    |    加    | 自左向右 | a + b |
|   3    |   -    |    减    | 自左向右 | a - b |
|   4    |   =    |   赋值   | 自右向左 | a = b |

​		运算符优先级：算术 > 关系 > 逻辑 > 赋值 > 逗号

**赋值运算符**

​		赋值也是运算，也有结果

​		`a = 6`的结果是a被赋予值6

​		`a = b`的结果是b。

​		由于赋值运算符是自右向左结合，所以`a = b = 6`等价于`a = (b = 6)`;

​		<u>嵌入式赋值</u>:不利于阅读，且容易产生错误，不建议使用。

```c
int a = 6;
int b;
int c = 1 + (b = a);
```

​		<u>复合赋值</u>：+ - * / %都可以和赋值运算符“=”结合起来，形成复合赋值运算符

​		如“+=”、“-=”、“*=”、“/=”、“%=”

​		注意符合赋值运算符的两个运算符中间不要有空格，否则编译器会提示语法错误，“**[Error] expected expression before '=' token**”

```c
total += 2;
total = total + 2;   //二者等价
```

**课后讨论2.3.1：不好的表达式**

> 看看如何分析这个表达式：
>
> a=5;
>
> c = (b=a+2) - (a=2);

答：

​		括号先算，从左往右，所以应该是b=5+2=7，后面的括号a=2，再是7-2=5，这个值在赋给c，所以c是5。最后结果是a = 2，b = 7，c = 5.

**交换两个变量的值**

​		程序是顺序执行的，所以简单的`a = b`，`b = a`是不行的，这样只能让两个变量都成为b的值。

​		为了交换两个容器的值，我们想到可以借用第三个容器。

```c
#include<stdio.h>

int main()
{
    int a = 2;
    int b = 5;
    int t;
    t = a;
    a = b;
    b = t;
    printf("a = %d, b = %d", a, b);
    
    return 0;
}
```

​		可以通过调试功能，观察上述各变量在交换过程中值是如何变化的。调试过程中可以在某一行设置断点，程序运行到此处时就会暂停，调试界面可以看到各变量的值。

​		上述代码就是C语言中，交换两个数的一般做法。学习编程，只学习语法是不够的，还需要积极积累“套路”，了解这个问题一般别人是怎么解决的，这样以后遇到类似问题处理起来就能得心应手了。学习套路的方式之一就是阅读。

```c
	a = a + b; 
	b = a - b; 
	a = a - b;
//上述代码可以实现不依靠中间变量交换两者的值
```

**递增递减运算符**

​		“++”、“--”是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量。这两个运算符分别叫作递增和递减运算符，它们的作用就是给这个变量+1、-1。

```c
count ++;
count = count + 1;
count += 1;      //三者等价
```

​		前缀、后缀：++、--既可以放在变量前面，叫作前缀形式，也可以放在变量后面，叫后缀形式。

​		`a++`的值(结果)是a+1以前的值，`++a`的值是a+1之后的值，但无论如何，这两段代码执行后a自己的值都+1了。

```c
int a;
a = 10;
printf("a++ = %d\n", a);
printf("a = %d\n", a);
printf("++a = %d\n", a);
printf("a = %d\n", a);
//输出结果
a++ = 10
a = 11
++a = 12
a = 12
```

| 表达式  |    运算    |   表达式的值    |
| :-----: | :--------: | :-------------: |
| count++ | 给count加1 |  count原来的值  |
| ++count | 给count加1 | count+1之后的值 |
| count-- | 给count减1 |  count原来的值  |
| --count | 给count减1 | count-1之后的值 |

​		这两个运算符有其历史来源

​		可以单独使用，但是不要组合进表达式里

```c
++i++;
i++++;
a = b += c ++ -d + --e/-f;   //组合进表达式就太复杂了
```

**课后讨论2.3.2：上课提到的那个复杂表达式该怎么理解？**

> a = b+=c++-d+--e/-f 

答：这个表达式包含了多个赋值和增减操作。为了更好地理解它，我们可以逐步拆解：

\1. **c++**: 这是后置自增操作。它返回`c`的当前值，并在返回之后将`c`增加1。

\2. **--e**: 这是前置自减操作。在返回`e`的值之前，它将`e`减少1。

\3. **b += ...**: 这是复合赋值操作。它将`b`的当前值加上`...`的结果，并将结果赋给`b`。

\4. **a = ...**: 这是普通的赋值操作。它将`...`的结果赋给`a`。

现在，我们可以结合上述操作来分析整个表达式：

```c
a = b += c++ - d + --e / -f
```

按照操作的优先级和结合性，这个表达式可以解释为：

\1. 首先计算`c++ - d`。这将使用`c`的当前值（然后`c`会增加1）和`d`的值。

\2. 接下来，计算`--e / -f`。首先，`e`会减少1，然后将结果除以`-f`。

\3. 将上述两个结果相加，得到`b += ...`的右侧的值。

\4. 更新`b`的值，并将结果赋给`a`。

​		请注意，这个表达式虽然在语法上是有效的，但是从代码可读性和维护性的角度来看，它是复杂的，因为它在一个简短的语句中包含了很多操作。这使得其他开发者（或甚至是你自己在一段时间后）很难理解其含义和目的。因此，在实践中，我们通常建议将这种复杂的表达式分解为多个更简单、更直观的语句。

```c
	int a = 1;
	int b = 3;
	int c = 7;
	int d = 15;
	int e = 24;
	int f = 35;
	
	a=b+=c++-d+--e/-f;
	
	printf("a=%d  b=%d  c=%d  d=%d e=%d  f=%d", a, b, c, d, e, f);
	
	//输出结果：a=-5  b=-5  c=8  d=15 e=23  f=35
```

#### 4.在线评判系统(Online Judge、OJ)

**注意事项**

​		除了题目要求的输出，不能输出其他内容，也不用设置任何用户友好型提示。

**各类提交状态提示**

​		**①**通过**(Accept，AC)**

​			表示代码通过了OJ的所有测试点。有些OJ系统设有部分通过的提示，说明有些测试点或者边界条件没有通过。

​		**②**答案错误**(Wrong Answer，WA)**

​			表示代码有错误，需要debug

​		**③**运行时间超限**(Time Limit Exceeded，TLE)**

​			有两种情况

​			a.代码运行过程中出现了死循环，需要进行 debug
​			b.代码时间复杂度过高，无法在规定时间之内处理所有数据，需要优化
​			解决方法：printf()调试大法、优化算法时间复杂度

​		**④**编译错误**(Compile Error，CE)**

​			说明代码中有不合法语句，需根据提示进行修改

​		**⑤**运行空间超限**(Memory Limit Exceeded，MLE)**

​			一般有两种情况

​			a.递归栈爆了
​			b.数组空间开太多了

​		**⑥**格式错误**(Presentation Error，PE)**

​			说明结果没按题目要求输出，请检查空格、换行符等等。

​		**⑦**段错误**(Segmentation Fault，SF)**

​			错误原因比较多，就是访问了不可访问的内存。

**边界测试**

​		程序的边界最容易出错，所以测试程序经常使用边界数据，如有效范围两端的数据、特殊的倍数等等

​		常用的边界数据：端点、0、负数等等

**章末习题：逆序的三位数**

> 程序每次读入一个正3位数，然后输出按位逆序的数字。注意：当输入的数字含有结尾的0时，输出不应带有前导的0。比如输入700，输出应该是7。
>
> ### 输入格式：
>
> 每个测试是一个3位的正整数。
>
> ### 输出格式：
>
> 输出按位逆序的数。
>
> ### 输入样例：
>
> ```in
> 123
> ```
>
> ### 输出样例：
>
> ```out
> 321
> ```
>

解答：

```c
#include<stdio.h>

int main()
{
  int n = 0;
  scanf("%d",&n);
  printf("%d",(n%10)*100 + (n%100/10)*10 + (n/100);
  //printf("%d",(n%10)*100 + (n/10%10)*10 + (n/100);也可以
  return 0;
}
```



### 第三章：判断与循环

#### 1.判断

**if语句-根据条件做还是不做**

​		根据之前计算时间差的讨论，如果这次我们就采用直接分别减的方案，判断有没有出现借位可以吗？

​		借位的结果是分钟小于0，出现借位我们再调整，我们从这里入手。

```c
int hour1, minute1;
int hour2, minute2;

scanf("%d %d", &hour1, &minute1);
scanf("%d %d", &hour2, &minute2);

int ih = hour2 - hour1;  
int im = minute2 - minute1;
if(im < 0)
{
    im = 60 + im;
    ih --;
}

printf("时间差是%时%分。", ih, im);  
```

​		上述代码中，我们使用了C语言中的条件判断语句，我们可以根据条件成立与否来判断接下来的动作是做还是不做。

```c
//if语句 写法
if(条件成立)
{
    ... 做复合语句内动作 ...
}
```

​		if语句后面可以不用大括号，但是if只对紧随其后的一句语句有效，注意，if语句结束的地方不在条件成立那个圆括号后，而是在后面的语句之后。

**判断的条件-关系运算符**

​		计算两个值之间的关系运算，所以又称为关系运算符。

| 运算符 |    意义    |
| :----: | :--------: |
|   ==   |    相等    |
|   !=   |   不相等   |
|   >    |    大于    |
|   >=   | 大于或等于 |
|   <    |    小于    |
|   <=   | 小于或等于 |

​		关系运算的结果只有0和1，如果关系成立，则为1，否则为0。

​		再次强调运算优先级：**算术 > 关系** > 逻辑 > 赋值 > 逗号

​		而同样在关系运算符内，判断相等的`==`和判断不等的`!=`优先级比其他关系运算符更低，为什么这么设定，是由于可以方便的做出诸如`5 > 3 == 6 > 4`的表达式。

​		连续的关系运算符是<u>从左到右</u>进行的

```c
5 > 3 == 6 > 4   //结果为1
6 > 5 > 4        //结果为0
a == b == 6      //结果为0
a == b > 0       //结果和a、b的值有关
```

**找零计算器-判断、注释、流程图**

​		找零计算器需要用户做的两个操作：输入购买的金额、输入支付的票面

​		找零计算器根据用户输入做的动作：计算并打印找零或者提示用户余额不足

​		从计算机角度看，就是意味着程序需要读用户的两个输入，然后进行一些计算和判断，最终输出结果。

```c
#include <stdio.h>

int main()
{
	//	初始化
	int price = 0;
	int bill = 0;
	//	读入金额和票面
	printf("请输入金额：");
	scanf("%d", &price);
	printf("请输入票面：");
	scanf("%d", &bill);
	//	判断票面够不够并计算找零
	if ( bill >= price ) 
    {
		printf("应该找您：%d\n", bill - price);
	}
    else 
    {
		printf("你的钱不够\n");
	}

	return 0;
}
```

​		上述程序我们使用了**注释(comment)**，把程序分成了清晰的三部分。注释是插入在程序代码内部，用来向读者提供解释信息，它们对程序功能没有任何影响，编译程序如何处理注释的请看课后讨论3.1.2。

​		延续多行的注释，使用`/*... ...*/`来写，注释内容由`/*`开始到`*/`结束，也可以用于一行内的注释。

​		注意，`//`单行注释是C99的注释，ANSI C不支持，而多行注释是一直都有的形式。

​		为了加深对条件判断的理解，这里提供第二个例子，可以画流程图辅助理解。

```c
#include <stdio.h>

int main()
{
	const int MINOR = 35;
	int age = 0;

	printf("请输入你的年龄: ");
	scanf("%d", &age);

	printf("你的年龄是%d岁。\n", age);  //人机交互常用方案：先输出刚才读取的内容，方便用户验证和阅览

	if ( age < MINOR ) 
    {
    	printf("年轻是美好的，");
	}

	printf("年龄决定了你的精神世界，好好珍惜吧。\n");

	return 0;
}
```

![3.0.drawio](笔记插图/3.0.drawio.png)

<center style="color:#C0C0C0">图3.0 年龄判断流程图</center>

**else{}语句-条件不成立应该做什么？**

​		我们前面知道，if语句满足条件判断，就会执行内部的复合语句，不满足则会执行if语句的下一条语句。可是，如果钱不够，条件不成立，应当做什么呢？简单的在if语句后面添加一条`printf("你的钱不够\n");`，会导致无论够不够，都会输出这句话，在钱足够的时候，该程序就会出现BUG。

​		C语言提供了一种方法，可以在if条件不满足时，执行另外的动作，这就是else()语句，else表示否则。

![3.1.drawio](笔记插图/3.1.drawio.png)

<center style="color:#C0C0C0">图3.1 找零计算器流程图</center>

​		else和if一样，后面可以不加大括号，但是else只对紧随其后的一句语句有效。

​		利用条件分支结构，可以很容易实现一个简单的功能——比较两数大小。

```c
int max1(int a, int b)
{
	int max = b;
	if ( a > b )
		max = a;
    
	return max;
}

int max2(int a, int b)
{
	int max = 0;
    if(a > b)
        max = a;
    else
        max = b;
    
	return max;
}
```

​		max1()似乎更聪明，更简洁，但max2()足够的傻，傻到任何人都能看懂，从某些评价角度看，也许第二种——让更多人能读懂的代码，要更好一些。

​		★典例一：应付薪水

```c
#include <stdio.h>

int main()
{
	const double RATE = 8.25;  
	const int STANDARD = 40;   
	double pay = 0.0;
	int hours;

	printf("请输入工作的小时数: ");
	scanf("%d", &hours);
	printf("\n");
	if (hours > STANDARD)
   		pay = STANDARD * RATE + 
   			(hours-STANDARD) * (RATE * 1.5);
	else
   		pay = hours * RATE;
	printf("应付工资: %f\n", pay);

	return 0;
}
```

​		★典例二：成绩是否通过

```c
#include <stdio.h>

int main()
{
	const int PASS=60;
	int score;

	printf("请输入成绩: ");
	scanf("%d", &score);
	
	printf("你输入的成绩是%d.\n", score);
	if ( score < PASS )
		printf("很遗憾，这个成绩没有及格。");
	else {
		printf("祝贺你，这个成绩及格了。");
		printf("再见\n");
	}

	return 0;
}
```

**课后讨论3.1.1：为什么强调if和else后面要用{ }**

答：

​		 人类可以采用多层缩进的书写格式，使程序层次分明，但C语言编译器会忽略缩进符。使用{...}能够明确地标识出这些语句属于if和else语句的范围，避免了可能的歧义，增加了代码的可读性和可维护性。 如果没有使用花括号，if和else语句只能控制其后的单个语句。 如果在单个语句后紧接着编写另一条语句，那么这条语句将始终会被执行，而不管if或else语句的条件是否为真或假。 因此，强调在 if 和 else 语句后使用花括号是为了确保代码的正确性和可读性。

**课后讨论3.2.2：/* */会被替换为什么？**

> ​		这个讨论是深入的讨论，第一次学习C语言的同学可以围观一下，看不懂也没关系。
> ​		/* */是注释，编译器不管其中的内容。但是有没有想过编译器会把它替换成什么呢？是一个空格？还是不留痕迹？可以写代码来测试你用的编译器吗？

答：

​		把代码翻译成汇编代码前，有个预处理的步骤，在处理过程中会把注释代码删掉。编译器替换内容，需要看注释在语句中的位置，位置不同，替换内容也不同，语句前及语句中的注释会被替换成空格，语句前注释被替换成等长空格，句中注释被替换成一个空格，语句末的注释 是直接删除。



#### 2.循环

**有些事情就得用循环才能解决**

​		if语句可以判断条件满足时才做相应的动作，而循环语句可以在满足条件时，不断地重复执行一些动作。

判断数的位数——程序要读入一个4位(含4位)的正整数， 然后输出这个整数的位数。

​		人直接通过眼睛看数位，判断数的位数，而计算机不擅长做这个，计算机擅长通过比较数在什么区间判断数的位数，而人是不擅长的，人对文字的处理能力比对数字的处理能力更强。

```c
#include<stdio.h> 

int main()
{
	int x; 
	int n = 1;

	scanf("%d", &x); 
	if( x > 999 )
    	n = 4;
	else if ( x > 99 )
		n = 3;
	else if( x > 9 ) 
		n = 2; 
	else
    	n = 1; 
   
 	printf("%d", n);
    
 	return 0;
}
```

​		上述程序有一个经典错误，就是将else全部改成if，即四个if判断四次。但是你需要注意，你写的程序是对步骤的描述，而不是关系或者说明，如果改写成四个if，那每个都会运行判断一次，最后都会输出 n = 1，显然是不对的。

​		题目明确了输入的是不超过四位的正整数，所以我们的程序可以按上面那样简化判断条件。

​		而且注意我们上面的程序是从高处往低处判断，这样每次判断可以排除掉一个确定的数位区间或者直接确定数位。

```c
	if( x > 0 )
    	n = 1;
	else if ( x > 9 )
		n = 2;
	else if( x > 99 )
		n = 3; 
	else
    	n = 4; 
```

​		如果像这样反过来，我们发现任何数都满足`x > 0`于是后面的条件判断都失效了，所以反过来是不可以的。

​		也可以得到推论，判断 x 大于某数，应该从高处往低处判断，x小于某数，应该从低处往高处判断。

​		但是，本节开篇的代码也有一定局限性，如果位数有很多位的时候，就需要非常多层if-else嵌套才能实现数位的判断，如何写一个通用的整数数位判断程序呢？受到人数数（数一个划掉一个）的启发，我们也可以让计算机“数数”，通过x = x/10，“数”一个数把最右边的一个数划掉，并且让计数器n ++，最终统计划掉所有数后n的值即可。

```c
#include<stdio.h>

int main()
{
	int x;
	int n = 0;
	
	scanf("%d", &x);
	
	while( x > 0 )
	{
		n ++;
		x /= 10;
	}
	
	printf("%d", n);
	
	return 0;
}
```

​		int型在计算机内部有表示整数的范围，所以上述程序依然不能判断任意一个数的整数位数哦！

**课后讨论3.2.1最大能数多大的数**

> 用课程中的那个数数的位数的程序，你能数到多大的数？

答：

​		C语言中，int型数据在内存中的存储形式是**补码**，32位补码所能表示的整数范围为$[-2^{-31},2^{31}-1]$，$2^{31}-1$ = 2147483647，所以最大可以数到10位正整数。

**while循环-条件满足就不停执行后面的语句**

​		如果我们把while翻译作“当”，while循环就是条件满足时，不断重复循环体内的语句。

```c
while( x > 0 )
{
    x /= 10;
    n ++;
}
```

```flow
st=>start: 前面的语句
 
cond=>condition: 条件满足？
 
while=>operation: 循环体
 
e=>end: 后续语句
 
st->cond
 
cond(yes, bottom)->while(left)->cond
 
cond(no)->e

```

<center style="color:#C0C0C0">图 while循环流程图</center>

​		循环体内要有改变条件的机会，否则会导致死循环（或称无限循环）。

​		根据while的执行逻辑，while里的循环体有可能一次都不执行。

​		没有计算机如何验证循环程序的结果？——答案是**手工模拟**：在纸上列出所有变量，随着程序的进行，按步骤不断重新计算变量的值并记录。当程序运行结束之后，手工模拟表格最后得到的值就是程序的最终运行结果。

**do-while循环：不管三七二十一，先做一次循环**

​		进入循环的时候不做检查，而是在执行完一轮循环体的代码之后，再来检查循环的条件是否满足，如果满足，则进入下一轮循环，不满足则结束循环。

​		do-while和while很像，区别只是什么时候判断条件，结果是do-while至少会做一次，而while有可能一次都不做。

```c
do{
    <循环体语句>
}while(<循环条件>);    //记得语句结尾有个;表示语句结束，语句结束用{ }或;
```

```flow
st=>start: 前面的语句

cond=>condition: 条件满足？

while=>operation: 循环体

e=>end: 后续语句

st->while

while->cond(yes)->while

cond(no,left)->e
```

<center style="color:#C0C0C0">图 do-while循环流程图</center>

**for循环**

​		for循环像一个计数循环：设定一个计数器，初始化它，然后在计数器达到某值之前重复执行循环体，而每执行一次循环体，计数器就进行一次值的调整。for中的三个表达式，每个表达式都是可以省略的`for(;条件;)`等价于`while(条件)`

```c
for(初始动作, 条件, 每轮的动作)
{
    ... ...
}
```

​		事实上，for循环一定可以和while循环相互转化。

```c
for(int i = 1; i <= n; i++)
{
    fact *= i;
}
//等价于
int i = 1;
while(i <= n)
{
    fact *= i;
    i ++;
}
```



```flow
st=>start: 前面的语句
 
cond=>condition: 条件满足？
 
for=>operation: 循环体

iadd=>operation: i ++

initialization=>operation: i = 1
 
e=>end: 后续语句
 
st->initialization->cond
 
cond(yes, bottom)->for(left)->iadd->cond
 
cond(no)->e
```

<center style="color:#C0C0C0">图 for循环流程图</center>

​		for可以读作“对于”，于是下面的for循环可以读成：“对于一开始`i = 10`，当`i > 0`时，重复执行循环体，每一轮执行完循环体内语句后，令`i --`。”

```c
for(int i = 10; i > 0; i--)
{
    .../*Code*/...
}
```

​		下面两种for循环的循环次数都是一样的，都为n，区别在于第一次循环i的值以及循环结束后i的值。注意，循环结束后，第一段代码的i为n，第二段代码的i为n+1，即对于for循环，i最终的值是**不满足**循环条件的值。

```c
for(i = 0; i < n; i ++)
{
	.../*Code*/...
}
for(i = 1; i <= n; i ++)
{
	.../*Code*/...
}
```

​		试编写程序，让用户输入n，计算阶乘$n! = 1 × 2×3 ... ×n$

```c
double factorial_a(int n)
{
    double product = 1;          //小套路：求积初值设为1，求和初值设为0。
    for(int i = 1; i <= n; i++)  //仅有C99支持for语句内定义初值i，这里从i从2开始也没问题，可以自行验证
        product *= i;

    return product;
}
//也可以逆向递减计数，实现的功能相同
double factorial_b(int n)
{
    double product = 1;          
    for(int i = n; i > 1; i--)   
        product *= i;

    return product;
}
```

**课后讨论3.2.2：为什么老师说for循环很怪？**

> ​		for循环是高级语言出现的第一种循环，它和现代的程序设计理念是否存在差距？为什么Python语言就没有C语言这种形式的for循环了？

答：

​		 for循环不符合人类的语言逻辑，不易理解，因此就造成了第一次接触语言的人觉得for循环很怪。而现代程序设计理念更强调与人类语言的逻辑统一性，所以在新兴的python语言中祛除掉了C中的for循环逻辑。但由于for循环抽象程度高，所以在掌握语言基础后，其表现逻辑更为简洁易于回溯反而更方便使用。

​		Python语言就没有for循环的另一个原因是Python里没有累加器。

**循环的选择**

​		本节三种循环体应该如何选择？

​		①如果有固定循环次数，用for 

​		②如果必须要做一次，用do-while 

​		③其他情况用while

**章末习题：时间换算（5分）**

> **题目内容：**
>
> UTC是世界协调时，BJT是北京时间，UTC时间相当于BJT减去8。现在，你的程序要读入一个整数，表示BJT的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而分小于10分，需要保留十位上的0；如果小时是0而分小于10分的，则不需要保留十位上的0。如1124表示11点24分，而905表示9点5分，36表示0点36分，7表示0点7分。
>
> 有效的输入范围是0到2359，即你的程序不可能从测试服务器读到0到2359以外的输入数据。
>
> 你的程序要输出这个时间对应的UTC时间，输出的格式和输入的相同，即输出一个整数，表示UTC的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而分小于10分，需要保留十位上的0；如果小时是0而分小于10分的，则不需要保留十位上的0。
>
> 提醒：要小心跨日的换算。
>
> **输入格式**
>
> 一个整数，表示BJT的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而分小于10分，需要保留十位上的0；如果小时是0而分小于10分的，则不需要保留十位上的0。
>
> **输出格式：**
>
> 一个整数，表示UTC的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而分小于10分，需要保留十位上的0；如果小时是0而分小于10分的，则不需要保留十位上的0。
>
> **输入样例：**
>
> 803
>
> **输出样例：**
>
> 3

解答：

```c
#include<stdio.h>

int main()
{
    int BJT;
    scanf("%d", &BJT);
    
    int hour1, minute1, t1;
    int hour2, minute2, t2;
    
    hour1 = BJT / 100;
    minute1 =  BJT  % 100;
    t1 = 60 * hour1 + minute1;
    t2 = t1 - 60 * 8;
    
    if(t2 >= 0 )
    {
        hour2 = t2 / 60;
        minute2 = t2 % 60;
    }else{
        t2 = 24 * 60 + t2;
        hour2 = t2 / 60;
        minute2 = t2 % 60;
    }    
    if(hour2 == 0)
        printf("%d", minute2);
    else if(minute2 < 10) 
    	printf("%d%02d", hour2, minute2);
    else
    	printf("%d%d", hour2, minute2);
    
    return 0;
}
```

**章末习题：分队列（5分）**

> **题目内容：**
>
> 班级第一次列队，通常老师会让同学按身高排成一列，然后1、2报数，喊到1的同学向前一 步，就这样，队伍就变成两列了。假设现在一个班级有n个同学，并且他们已经按身高排成了一列，同学按身高从1到n编号，你能告诉我最后哪些编号的同学站在了第一列么? 
>
> **输入格式:**
>
> 输入一个正整数n，表示班级的人数。
>
> **输出格式：**
>
> 按顺序输出所有在第一列的同学对应的编号，每两个编号之间用一个空格隔开，最后一个编号后面没有空格。
>
> **输入样例：**
>
> 11
>
> **输出样例：**
>
> 1 3 5 7 9 11

解答：

```c
#include<stdio.h>

int main()
{
    int n;
    scanf("%d", &n);
    
    int odd = 1;
    if(n % 2 == 0)
        odd = 0;
    
    for(int i = 1; i <= n; i = i + 2)
    {
        printf("%d", i);
        if(odd == 1)
		{
        	if(i != n)
        		printf(" ");
		} 
        else
        {
        	if(i != n - 1)
                printf(" ");
		}       
    }
    
    return 0;
}
```



### 第四章：进一步的判断与循环

#### 1.逻辑类型与运算

**bool类型**

​		bool类型(布尔类型)：最早C语言是没有bool类型的，C89开始有这类逻辑运算类型的苗头，C99正式确立了这种新的类型。它不是C语言真正的原生类型，包含#include<stbool.h>头文件之后，就可以使用bool、true和false。

​		注意，bool其实不是一个新类型，它也属于整数类型。

**逻辑运算**

​		逻辑运算是对逻辑量进行的运算，结果只有0或1

​		逻辑量是关系运算或者逻辑运算的结果

| 运算符 |  描述  |   示例   |                             结果                             |
| :----: | :----: | :------: | :----------------------------------------------------------: |
|   !    | 逻辑非 |    !a    |             如果a是true，结果就是false，反之则反             |
|   &&   | 逻辑与 |  a && b  | 如果a和b都是true，结果才是true，其中有一个为false，结果就为false |
|  \|\|  | 逻辑或 | a \|\| b | 如果a和b有一个为true，结果就是true，两个都为false，结果才为false |

​		第三次强调运算符优先级：括号 > 算术 > 关系 > 逻辑 > 赋值 > 逗号

​		但是有一个特殊的地方，逻辑非是单目运算符，还有另一套适用规则

​		优先级：单目运算符 > 双目运算符

​		因此对于表达式`!age < 20`，由于`!age`只能为0或1，所以`!age < 20`表达式永远为1。

> 注记：
>
> 反之亦然：( p → q ) ↔ ( q → p );
>
> 反之则反：( p → q ) ↔ ( ﹁p → ﹁q );

​		同样的，逻辑运算符内部的优先级也不一样，将已学过的所有运算符整理为下表

| 优先级 |    运算符     |        结合性         |
| :----: | :-----------: | :-------------------: |
|   1    |      ()       |       从左到右        |
|   2    |  ! + - ++ --  | ★从右到左(单目的+和-) |
|   3    |     * / %     |       从左到右        |
|   4    |      + -      |       从左到右        |
|   5    |   < <= > >=   |       从左到右        |
|   6    |     == !=     |       从左到右        |
|   7    |      &&       |       从左到右        |
|   8    |     \|\|      |       从左到右        |
|   9    | = += -= *= /= |       ★从右到左       |

​		如果要表达数学中的区间，如x∈(2,5)，应该如何写C的表达式呢？

​		通过第三章及本章，我们可以知道C语言描述关系和数学语言有一点不同，`2 < x < 5`的表达式在C中表达的是一个逻辑值0或1，正确的C语言表达式是：`x > 2 && x < 5`

**字符型数据**

​		**字符型常量**指的是单个字符，用一对**单引号**及其括起来的字符来表示，每个字符都有一个唯一的次序值，即**ASCII码**。

​		`'$'、''、'\n'、'\063'、'\x41'`都是合法的字符常量，第二个两个单引号之间没任何东西，叫做空字符常量。第三个是合法的转义字符常量，`'/'`是合法的字符常量，但`'\'`是非法的字符常量。`'\ddd'`表示 1到3位8进制数所代表的字符(d不能大于等于8)；形式`'\xhh'`表示1到2位16进制数所代表的字符。C语言字符集中的任何一个字符均可用转义字符来表示。上面的`'\ddd'`和`'\xhh'`正是为此而提出的，分别为八进制和十六进制的ASCII代码。

​		数字字符'0'，'1'，...，'9'、大写字母'A'，'B'，...，'Z'、小写字母'a'，'b'，...，'c'，**分别**都是按ASCII码升序连续排列，所以判断一个字符c是否为大写字母，可以使用`c>='A' && c <= 'Z'`来判断。

​		常用ASCII码表：

|  字符  | ASCII码 |
| :----: | :-----: |
| 空字符 |    0    |
|  空格  |   32    |
|   0    |   48    |
|   A    |   65    |
|   a    |   97    |

​		可以知道，数字、大写字母、小写字母的ASCII码三块，块内连续升序排列但块间不是连续的，而且小写字母的ASCII码比大写字母更大。

```c
	//ch 是空格或者回车。
	ch == ' ' || ch == '\n'  //要两个ch分别判断，和文字描述有点区别，不能ch == ' ' || '\n'
    //number是偶数
    number % 2 == 0
    //year是闰年，即year能被4整除但不能被100整除，或year能被400整除
    (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)
    //ch不是小写字母，注意是“或”
    ch < 'a' || ch > 'z'
    //ch是英文字母。
	(ch >= 'A' && ch  <= 'Z') || (ch >= 'a' && ch  <= 'z')
```

​		**字符型变量**在定义时用类型名char，例如`char op;`定义了一个字符型变量op，它的值是字符型数据。`op='+'`将字符型常量`'+'`赋给字符型变量op。

​		`scanf()`和`printf()`也可以处理字符型数据的输入输出，在函数调用的格式控制串中相应的格式控制说明为%c。

```c
scanf("%lf%c%lf", &value1, &op, &value2);
```

​		上述代码就是读入两个操作数和一个运算符，操作数和运算符之间不能出现空格，因为空格本身也是个字符，会被作为输入字符。

**字符型数据的输入与输出**

​		调用字符输入函数`getchar()`可以从键盘输入一个字符，设ch是字符变量，函数`getchar()`的一般调用格式为：

```c
ch = getchar();
```

​		功能是从键盘输入一个字符，并赋值给变量ch。

​		由于`getchar()`每次只能读入一个字符，要输入多个字符一般采用**循环调用**的方式。

​		调用字符输出函数`putchar()`可以输出一个字符，函数`putchar()`的一般调用格式为：

```c
putchar(输出参数);
```

​		其功能是输出字符型变量或字符型常量

​		字符常量在程序中有单引号，但用户输入输出时，字符两侧没有单引号。

​		下列程序顺序输入`'Q'`后，输出`'`

```c
#include<stdio.h>

int main()
{
	char ch;
	ch = getchar();
	putchar(ch);
	
	return 0;
}
```

**短路**

​		逻辑运算是自左向右进行的，如果左边的结果已经能够决定右边的结果了，就不会做右边的表达式。

​		对于`&&`来说，左边为false时就不做右边了

​		对于`||`来说，左边为true时就不做右边了

​		因此，不要把赋值语句或者复合赋值组合进表达式，这样就不会因为C语言的短路特性导致代码出错。

**条件运算和逗号运算**

​		条件运算符最初起源于BCPL程序设计语言，而B语言就是C语言的前身，所以条件运算符也属于历史遗留问题

```c
//条件运算符格式
条件判断 ? 条件满足 : 条件不满足
```

​		条件运算符的优先级高于赋值运算符，但是低于其他的所有运算符。

​		条件运算符是**自右向左**结合的，所以如果遇到复杂的嵌套条件运算，需要先把分支算清楚再回溯到最外层。

​		条件运算符看似将if-else的选择结构简化为了一句语句，但如果表达式存在赋值语句或者存在嵌套条件运算，会大大增加阅读和维护代码的难度，因此不建议使用嵌套的条件表达式。

**逗号运算**

​		逗号在C语言中属于一种运算符，其优先级甚至比赋值运算还低。

​		带括号的逗号表达式，结果是逗号后面那个表达式

```c
 //i的结果为7
i = 2 + 5, 5 + 6;
//i的结果为11
i = (2 + 5, 5 + 6);
```

​		因此，C语言中以下a、b变量初始化的方式是错误的，它会导致a的初值不确定，b被赋初值0；

```c
int a, b = 0;
```

​		目前，逗号表达式主要用于for语句，如果在for内三块区域需要进行多个计算，就可以在区域内使用逗号表达式实现

```c
for(i = 0, j = 10; i < j; i ++, j-- )
```

#### 2.级联和嵌套的分支结构

**级联的else if语句**

​		else if语句是最常用的实现多分支（多路选择）的方法，其一般形式为：

```c
if(表达式1)
    语句1;
else if(表达式2)
    语句2;
...
else if(表达式n-1)
    语句n-1;
else
    语句n;
```

​		这里把它称为级联的else if语句，执行流程图如下所示。

![4.0.drawio](笔记插图/4.0.drawio.png)

<center style="color:#C0C0C0">图4.0 else if 流程图</center>

​		else if语句在仍然保持逻辑清晰的前提下，简化了代码的写法。当然，我们可以把任何一个级联的else if分支结构改成只用if和else语句的分支结构，不过这样就需要利用缩进不断向右缩进，层数很多时代码会变得不简洁、不美观。

​		利用else if语句，可以方便地描述下面的分段函数，并打印不同自变量下f的值。
$$
y=f(x) = \begin{cases}
  -1 &  x < 0 \\
  0 &  x= 0 \\
  2x & x>0
\end{cases}
$$

```c
int f;
if(x < 0)
    f = -1;
else if(x == 0)
    f = 0;
else
    f = 2 * x;
printf("%d", f);
//另外的实现方式
if(x < 0)
    printf("%d", -1);
else if(x == 0)
    printf("%d", 0);
else
    printf("%d", 2 * x);
```

​		上述两段代码各自都能实现相同的功能，但是从程序设计角度看，更倾向于选择第一种写法。因为它属于**单一出口**(出口是指程序结束的地方，第二段代码有三处地方直接用`printf()`把结果返回给用户看了，第一段代码只有最后一处地方向用户打印值)。

​		第一种写法最后才打印f的值，之前不涉及对f的操作，如果之后要额外对f进行其他计算或者通过函数返回到高层都很容易方便、灵活的添加；

​		而第二种写法，固定了这段代码就只能把分段函数不同自变量下的函数值返回给用户看，不够灵活。如果一个很复杂的工程文件，有个复杂的模块中间有好几个出口，也会给软件测试增大难度。

**嵌套的if-else语句**

​		当if或else条件满足或者不满足的时候执行的语句也可以是一条if或者else语句，这就是嵌套的if-else语句。

​		下面的代码就实现了4路分支，必要时第三层语句还可以是基本的if else语句，从而实现更多路的分支。

```c
int a, b, c;
scanf("%d %d %d", &a, &b, &c);

int max = 0;
//虽然下面采用省略{}的if-else语句，但要注意，这样做编译器、其他阅读者有误解这些if-else对应匹配的可能。
//缩进字符只能让人类更便于阅读和理解，并不能在C语言中表明if-else的匹配
if(a > b)
    if(a > c)
        max = a;
	else
        max = c;
else
    if(b > c)
        max = b;
	else
        max = c;

printf("Tha max number is %d", max);
```

![4.0.drawio](笔记插图/4.1.drawio.png)

<center style="color:#C0C0C0">图4.1 比较三个数的大小 流程图</center>

​		else总是和之前与其最近的且不带else的那个if匹配，通过加大括号，可以改变if-else对应的匹配，比如将上面的程序修改为下面这段程序，此时第二个if就没有对应的else和它匹配了。

```c
if(a > b)
{
	if(a > c)
	max = a;
}
	else
        max = c;
```

​		代码中使用缩进字符只能让人类更便于阅读和理解，并不能在C语言中表明if-else对应的匹配关系。有时候，虽然某个else和if书写格式对齐，但由于它与第二个if距离最近，于是会与第二个if匹配。

​		我们可以保持一个好的代码习惯，使用C语言时，在if和else后面，即使只有一条语句也始终加上大括号{... ...}，这样可以避免很多不必要的麻烦。

​		如果不使用{ }，则需要注意对应关系，且不要随意省略else部分，即使其为空语句，这样if和else数量相同，从内层到外层一一对应，结构清晰，不易出错。

#### 3.switch-case多路分支

**switch-case语句：多分支选择**

​		switch语句可以处理多分支选择问题，根据其中break语句的不同用法，可以实现不同的功能。

```c
switch(控制表达式)
{
    case 常量表达式1:
   		语句段1
    	...
    case 常量表达式2:
   		语句段2
    	...
    default:
    	语句段3
    	...
}
```

​		控制表达式只能是整数型的结果

​		常量表达式包括整型或字符型，也可以是常量的运算表达式，所有的常量表达式的值<u>不能相等</u>。相等的话编译器会报错，[Error] duplicate case value 和 [Error] previously used here。

​		case后面**不能**是**关系表达式**，也不能是**变量**或**变量表达式**，比如

```c
case op == '+': printf("%d\n", value1 + value2); break;
//
case n % 3: printf("one");
```

​		语句段可以有若干条语句，也可以为空语句

​		default可以省略，省略之后，若控制表达式不满足任何一个常量表达式的值，则什么都不做。

​		case也可以没有，没有case就直接执行default后面的语句。

**break语句**

​		switch语句可以看作是一种基于计算的跳转，由下面虚线框可以看到，switch语句中的“case常量表达式”和“default”的作用相当于语句标号（分支标号）。计算控制表达式的值后，程序会跳转到相匹配的case（分支标号）处。		

​		分支标号只是说明switch内部位置的路标，在执行完分支中的最后一条语句后，如果后面没有break，就会<u>顺序执行到下面的case里去，直到遇到一个break</u>，或者switch结束为止。

​		由此可见，在switch语句的所有语句段的末尾使用break，可以简单、清晰地实现多分支选择，这也是switch语句的主要使用方法。

​		break除了可以用在switch语句中，也可以用于其他循环语句中，用于中断循环。

![4.2.drawio](笔记插图/4.2.drawio.png)

<center style="color:#C0C0C0">图4.2 swich语句 流程图</center>

​		也可以选择仅仅在某些语句段末尾使用break以实现特殊功能，比如下述代码可以识别读入字符的是不是回车或者空格字符二者的其中之一。

```c
char ch = getchar();
int blank = 0;
switch(ch)
{
    case ' ':
    case '\n':
        blank++;
        break;
}
```

​		下面是一个将一个百分制成绩转换为五分制成绩的程序。类似地，也可以编写一个输入月份转换为对应英文单词的程序。

```c
#include<stdio.h>

int main()
{
    int grade;
    scanf("%d", &grade);
    grade /= 10;

    switch( grade )
    {
        case 10:
        case 9:
            printf("A\n");
            break;
         case 8:
            printf("B\n");
            break;
         case 7:
            printf("C\n");
            break;
         case 6:
            printf("D\n");
            break;
         default:
            printf("E\n");
            break;
    }

    return 0;
}
```

​		这段代码不符合“单一出口”的原则，学习过字符或者字符串数据的处理章节之后可以回过头来把这个程序改写成单一出口的程序。月份转换的程序也可以在学习过数组章节再回过头改写得更加简洁和漂亮。

**课后讨论4.3.1分段函数可以用switch-case吗？划算吗？**

> 分段函数可以用switch-case吗？划算吗？视频中最后的那个分段函数，真的可以用switch-case吗？  

解答：

​		可以使用，但是还是少不了判断，使用了相当于多了很多步骤，不划算；而且分段函数的自变量x是范围，如果硬要用switch-case语句实现，需要先做一次判断转化为整型。

```c
int main()
{
    int x, n;
    
    scanf("%d", &x);
    
    if(x < 0)
        n = 1;
    else if(x == 0)
        n = 2;
    else
        n = 3;
    
    switch(n)
    {
        case 1: printf("f = -1\n"); break;
        case 2: printf("f = 0\n"); break;
        case 3: printf("f = %d\n", 2 * x); break;
    }
    
    return 0;
}
```

#### 4.循环的典例

**循环计算**

​		★典例一：计算$log_2 m$

```c
int x;
int ret = 0;

scanf("%d", &x);
int t = x;
while(x > 1)
{
    x /= 2;
    ret ++;
}

printf("log2 of %d is %d", t, ret);
```

​		小套路：循环过程中可能发生改变的值，可以先保存原始值，后面有可能有用。

​		现在问题是，上述程序代码中，ret的初值以及while满足的条件是如何确定的呢？这两个值其实是息息相关的，而且也不一定只有唯一答案。

​		一个思路是，直接考虑边界条件，1以2为底的对数是0，所以希望`x = 1`时，不进入while循环，于是可以知道ret = 0，while里面的条件是`x > 1`或者`x >=  2`，反过来考虑，假如我就想让while里面的条件是`X > 0`呢？此时1会进入循环，然后`ret ++`，所以，此时的ret初值应该设置为`ret = 0`；

​		当然，此类问题初值的确定，主要还是依靠个人经验，熟能生巧。

​		★典例二：计数循环

```c
int count = 100;
while(count >= 0)
{
    count --;
    printf("%d\n", count);
}
printf("发射！\n");
```

​		这个循环需要执行多少次？循环结束后，有没有输出最后的0？循环结束后，count的值为多少？循环最后输出的数字是多少？

​		小套路：要回答上述四个问题，我们可以模拟运行上述程序。如果要模拟运行一个很大次数的循环，可以手工模拟较少的循环次数，然后根据规律归纳并做出推断。

​		手工模拟运行程序，假设count = 3；模拟后，由下面的表格可以知道count = 3时，循环执行了4次，0输出了，循环结束后count的值为-1，循环最后输出-1。所以四个原问题的答案为：101次、有、-1、-1。

|  n   | 输出结果：2 1 0 -1 |
| :--: | :----------------: |
|  3   |                    |
|  2   |                    |
|  1   |                    |
|  0   |                    |
|  -1  |                    |

**求平均数**

​		思考，该程序需要哪些变量？

​		①平均数要怎么算？$Average = \frac{\sum_{i = 1}^{n}{x_i}}{n} $

​		②一个读整数的变量变量。

​		③一个累加变量。不需要永久记录每个成绩数据，只需要把它依次加到累加里变量里，读完所有成绩后再除以读到个数即可。

​		④一个记录累加次数的变量。

![4.3.drawio](笔记插图/4.3.drawio.png)

<center style="color:#C0C0C0">图4.3 求平均数 流程图</center>

```c
#include<stdio.h>

int main()
{
    int number;
    int sum;
    int count;
    
    scanf("%d", number);
    while(number != -1)
    {
        sum += number;
        count ++;
        scanf("%d", &number);
    }
    
    printf("%.2f", 1.0 * sum / count);
        
    return 0;
}
```

**猜数游戏**

​		让计算机来想一个数，然后让用户来猜，用户每输入一个数，就告诉它是大了还是小了，直到用户猜中为止，最后还要告诉用户它猜了多少次。

​		因为需要不断重复让用户猜，所以需要用到循环

​		在实际写出程序之前，我们可以先用文字描述程序的思路

​		核心重点是循环的条件，人们往往会考虑循环终止的条件

​		文字描述：

​		1．计算机随机想一个数，记在变量number里；

​		2．一个负责计次数的变量count初始化为0；

​		3．让用户输入一个数字a；

​		4．count递增（加一）；

​		5．判断a和number的大小关系，如果a大，就输出“大”；如果a小就输出“小”；

​		6．如果a和number是不相等的（无论大还是小），程序转回到第3步；

​		7．否则，程序输出“猜中”和次数，然后结束。

```c
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

int main()
{
	srand(time(0));
	int number = rand()%100+1;
	int count = 0 ;
	int a = 0;

	printf("我已经想好了一个1到100之间的数。");
    do{
		printf("请猜这个1到100之间数：");
         scanf("%d", &a);
		count ++;
		if( a > number )
    	{
		printf("你猜的数大了。");
    	} else if ( a < number ){ 
        printf("你猜的数小了。");
    	}

	}while (a != number);

	printf("太好了，你用了%d次就猜到了答案。\n", count);
    
    return 0;
}
```

​		`rand()`是一个库函数，每次调用可以得到一个随机数。

​		使用`srand(time(0));`语句保证每次产生的随机数不一样。

**课后讨论4.4.1：为什么100以内的数猜7次就够了？**

> 课程中的猜数游戏，为什么100以内的数猜7次就够了？  

答：

​		使用二分查找在每次进行猜数的时候范围都会缩小1/2，也换句话来说也就是每次的每猜测一次，剩下的数的数量就会减少一半，而2的7次方是128，所以最多也就猜7次。

**整数求逆**

​		整数的分解：

​		①一个整数是由一至多位数字组成的，要想获得他的逆序，一个思路是分解出它每一位上的数字，然后处理。

​		②对一个整数做%10运算，可以获得它的个位。

​		③对一个整数做/10的操作，就去掉了它的个位，然后再对结果%10，就得到原来整数的十位，以此类推。

```c
#include<stdio.h>

int main()
{
    int x;
    scanf("%d", &x);
    
    int digit;
    int ret = 0;
    
    while(x > 0)
    {
        digit = x % 10;
        ret = 10 * ret + digit;
        //printf("x = %d, digit = %d, ret = %d\n", x, digit, ret); //调试信息
        x /= 10;
    }
    
    printf("%d", ret);
    
    return 0;
}
```

​		如果要让逆序之后的数，即使为0也保留数位并逆序，比如输入700，输出007，可以简单修改上述代码获得。

```c
  while(x > 0)
    {
        digit = x % 10;
      	printf("%d", digit);
        ret = 10 * ret + digit;
        x /= 10;
    }
    
    //printf("%d", ret);
```

#### 5.判断和循环的常见错误

**代码风格**

​		①if和else之后必须加上大括号形成语句块。

​		②大括号内的语句缩进一个tab的位置。

```c
//风格一：可以看的代码行数多、紧凑
if(x < 0){
    f = -1;
}else if(x == 0){
    f = 0;
}else{
    f = 2 * x;
}
//风格二：中庸、括号匹配更清晰
if(x < 0){
    f = -1;
}else if(x == 0)
{
    f = 0;
}else
{
    f = 2 * x;
}
//风格三：括号匹配最清晰、松散、方便用快捷键注释多行
if(x < 0){
    f = -1;
}
else if(x == 0)
{
    f = 0;
}
else
{
    f = 2 * x;
}
```

​		“风格是三观……”，上面三种风格依照个人喜好及需要都可以用，但请尽量遵守前两点规则。

**经典疑问**

​		★典例一、设变量已正确定义，以下____是合法的switch语句。(本题假设，在考虑每一句switch语句时，其他的switch语句都是被注释的状态)

```c
#include<stdio.h>

int main()
{
	char op = '+';
	int value1, value2;
	value1 = value2 = 2; 
	//语句A：
	switch(op)
	{
       default: printf("Error\n"); break;
	}
	//语句B：
	switch('/'){
       case '*': printf("%d\n", value1 * value2); break;
       case '-': printf("%d\n", value1 - value2); break;
       case '+': printf("%d\n", value1 + value2); break;
       default: printf("Error\n"); break;
	}		
	//语句C：case后面不能跟关系表达式
	switch(op){
       case op == '+': printf("%d\n", value1 + value2); break;
       default: printf("Error\n"); break;
	}
	//语句D：
	switch(op+1){
       default: printf("Error\n"); break;
       case '*': printf("%d\n", value1 * value2); break;
       case '+': printf("%d\n", value1 + value2); break;
	}
	//语句E：有两处case值为'*'
	switch(op){
       case '*': printf("%d\n", value1 * value2); break;
       case '+': printf("%d\n", value1 + value2); break;
       case '-': printf("%d\n", value1 - value2); break;
       case '*': printf("%d\n", value1 * value2); break;
       default: printf("Error\n"); break;
	}
	
	return 0;
}
//答案：ABD
```

​		★典例二、default位置变了，会对结果产生什么影响。下面代码输入`100 90 82 72 69`，请问输出是____。

```c
#include<stdio.h>

int main()
{
	char grade;
	int i, score;
	for( i = 1; i < 6; i++)
	{
    scanf("%d", &score);
    score = score/10;
    switch(score) 
	{
        case 10: 
        case 9: 
        default: grade = 'F'; break;
        case 8: grade = 'A'; break;
        case 7: grade = 'P'; break;
    }
    putchar(grade);
	}
	
	return 0;
}
//答案：FFAPF
```

​		我们可以推测出以下结论：不管你编写的代码中default放在那里，这里的条件判断都是先按顺序比较其他非default值，当这些条件都不满足的时候，才跳转到default的相应代码处执行，可以参考switch语句翻译成的汇编语言来理解。

​		值得注意的是，这并不意味着default的位置不影响结果，事实上，如果default提前，当其他case都不满足时，会从default位置执行default后面的语句以及之后的case语句，直到break或switch结束。

​		典例三、写出与以下switch语句等价的else-if语句。

```c
switch (ch){
    case '0' : case '1' : case '2' : case '3' : case '4' :
    case '-': 
        minus++; break; 
    case '5' : case '6' : case '7' : case '8' : case '9' : 
        digit ++;break;
    default: 
       other ++; break; 
}   
```

答：

```c
if(ch == '-' || (ch >= '0' && ch <= '4'))
 {
    minus++; 
 }
else if(ch >= '5' && ch <= '9')
{
    digit ++;
}
else 
{ 
	other ++;
}
```

​		典例四、结尾不要输出空格！

​		输入一个正整数n，再输入n个整数，输出其中的偶数。要求相邻数字中间用一个空格分开，行末不得有多余空格。补全代码。

```c
# include <stdio.h>
//补全下面注释处的代码(4分)
int main()
{
    char ch;
    int first, k, n, x; 

    scanf("%d", &n);
    /*             */
    for(k = 1; k <= n; k++){
        scanf("%d", &x); 
        /*             */
		{
            if ( first == 1 )
            { 
                printf("%d", x); 
               	/*         */
            }
            else
            { 
           		/*        */ 
            }
        }
    }

    return 0;
}
```

​		答案：四处按顺序依次为①`first = 1;` ②`if (x % 2 == 0); `③`first = 0; `④`printf(" %d", x);`

**课后讨论4.5.1你犯过哪些错误**

> 做完这几周的编程题，再回来看看这个常见错误的视频，汇报一下你曾经犯过哪些错误。

答：

​		①scanf输入忘记加&

​		②采用中文输入法

​		③if(条件判断)后面加分号；

​		这样会导致编译器认为你if后面是空语句。

​		④忘记加{ }导致匹配逻辑错误

​		每个if、else后面都习惯性写上{ }即可避免该错误

​		⑤赋值运算符"="和条件运算符"=="混淆

​		a = b的值是b，也可以通过编译器，但会提示warning，请尊重warning！

**章末习题：奇偶个数（5分）**

> **题目内容：**
>
> 你的程序要读入一系列正整数数据，输入-1表示输入结束，-1本身不是输入的数据。程序输出读到的数据中的奇数和偶数的个数。
>
> **输入格式:**
>
> 一系列正整数，整数的范围是（0,100000）。如果输入-1则表示输入结束。
>
> **输出格式：**
>
> 两个整数，第一个整数表示读入数据中的奇数的个数，第二个整数表示读入数据中的偶数的个数。两个整数之间以空格分隔。
>
> **输入样例：**
>
> 9 3 4 2 5 7 －1 
>
> **输出样例：**
>
> 4 2

解答：

```c

```

**章末习题：数字特征值（5分）**

> **题目内容：**
>
> 对数字求特征值是常用的编码算法，奇偶特征是一种简单的特征值。对于一个整数，从个位开始对每一位数字编号，个位是1号，十位是2号，以此类推。这个整数在第n位上的数字记作x，如果x和n的奇偶性相同，则记下一个1，否则记下一个0。按照整数的顺序把对应位的表示奇偶性的0和1都记录下来，就形成了一个二进制数字。比如，对于342315，这个二进制数字就是001101。
>
> 这里的计算可以用下面的表格来表示：
>
> |    数字    |  3   |  4   |  2   |  3   |  1   |  5   |
> | :--------: | :--: | :--: | :--: | :--: | :--: | :--: |
> |    数位    |  6   |  5   |  4   |  3   |  2   |  1   |
> |  数字奇偶  |  奇  |  偶  |  偶  |  奇  |  奇  |  奇  |
> |  数位奇偶  |  偶  |  奇  |  偶  |  奇  |  偶  |  奇  |
> |  奇偶一致  |  0   |  0   |  1   |  1   |  0   |  1   |
> | 二进制位值 |  32  |  16  |  8   |  4   |  2   |  1   |
>
> 你的程序要读入一个非负整数，整数的范围是[0,1000000]，然后按照上述算法计算出表示奇偶性的那个二进制数字，输出它对应的十进制值。
>
> *提示：将整数从右向左分解，数位每次加1，而二进制值每次乘2。*
>
> **输入格式:**
>
> 一个非负整数，整数的范围是[0,1000000]。
>
> **输出格式：**
>
> 一个整数，表示计算结果。
>
> **输入样例：**
>
> 342315
>
> **输出样例：**
>
> 13

解答：

```c

```



### 第五章：循环控制

#### 1.**循环控制**

**循环控制**

**课后讨论5.1.1：利用循环变量来判断素数不好吗？**

> 课程中提到有种“聪明”的做法，可以不设isPrime，直接利用循环出口处循环变量和终点值的关系来判断循环是否break了。你觉得这种做法好吗？

答：

​		这段代码可能存在以下问题：

​		①当输入的数小于等于 1 时，程序无法正确判断素数。因为在这种情况下，程序内部的 for  循环不会执行，导致无法区分该数是素数还是合数。

​		②当输入的数较大时，程序的执行效率会比较低。因为程序需要遍历从 2 到该数减1的所有自然数，当该数非常大时，循环次数也非常多，导致程序运行速度变慢。

​		③没有对用户输入进行错误处理。如果用户输入的不是整数，程序就会出现意料之外的错误。变量 i 的类型为  int，如果要判断的数比较大，可能会导致整型溢出的问题。

​		④程序中没有考虑多线程的情况，可能会导致线程安全性问题。

​		⑤变量的命名不够规范，例如变量 i 不易于理解其含义。

#### 2.多重循环

**嵌套的循环：在循环里面还是循环**

**从嵌套的循环中跳出：break只能跳出其所在的循环**

**课后讨论5.2.1 goto怎么了？**

> 这是扩展的讨论内容，初学者可以只是围观看看，看不懂也没关系。
> 为什么课程中说goto的名声不好？用goto会怎么不好了？

答：

​		如果谨慎使用，goto或许不会让人感到迷惑，然而一旦引入goto语句，它们就会遍布于代码之间，就像房子里有了白蚁。一旦允许使用goto，那么坏的goto就会与好的混在一起，所以最好还是禁止使用它们。

​		一、反对GOTO的人的观点

 

​		普遍理由是：没有使用goto的代码就是高质量的代码，更容易证明其正确性。

​		原因一：含有goto的代码很难安排好格式。用缩进来显示goto及其目标的逻辑结构非常难。

​		原因二：使用goto的代码破坏编译器的优化特性。有些优化要求程序的控制流程位于不多的几个语句之间，而无条件的goto却使得流程变得很难分析，从而削弱了编译器优化代码的能力。

​		原因三：在实践中，使用goto会违背代码应该严格自上而下运行的原则，破坏结构化设计风格。

​		原因四：经常带来错误或者隐患，可能跳过变量的初始化以及重要的计算等。



​		二、支持GOTO的人的观点：

​		goto的支持者通常都会强调要在特定的场合下谨慎地使用goto。

​		条件一：如果使用位置恰当，goto可以减少重复的代码。如果不能一致地修改，重复的代码就会带来问题。重复代码还增加了源代码和可执行文件的体积。与代码重复所带来的问题相比，goto所具有的一些负面影响就显得不那么重要了。

​		条件二：goto在分配资源.使用资源后再释放资源的子程序里非常有用。通过使用goto，你可以在一段代码里执行清理操作。这将减少你在某个检测错误的位置发现问题后忘记释放资源的可能。

​		条件三：在某些情况下，使用goto会让代码的运行速度更快，体积更小。

#### 3.循环应用

**前n项求和**

**求最大公约数**

**整数分解**

**章末习题：素数和（5分）**

> **题目内容：**
>
> 我们认为2是第一个素数，3是第二个素数，5是第三个素数，依次类推。
>
> 现在，给定两个整数n和m，0<n<=m<=200，你的程序要计算第n个素数到第m个素数之间所有的素数的和，包括第n个素数和第m个素数。
>
> **输入格式:**
>
> 两个整数，第一个表示n，第二个表示m。
>
> **输出格式：**
>
> 一个整数，表示第n个素数到第m个素数之间所有的素数的和，包括第n个素数和第m个素数。
>
> **输入样例：**
>
> 2 4
>
> **输出样例：**
>
> 15

解答：

```c

```

**章末习题：念整数（5分）**

> **题目内容：**
>
> 你的程序要读入一个整数，范围是[-100000,100000]。然后，用汉语拼音将这个整数的每一位输出出来。
>
> 如输入1234，则输出：
>
> yi er san si
>
> 注意，每个字的拼音之间有一个空格，但是最后的字后面没有空格。当遇到负数时，在输出的开头加上“fu”，如-2341输出为：
>
> fu er san si yi
>
> **输入格式:**
>
> 一个整数，范围是[-100000,100000]。
>
> **输出格式：**
>
> 表示这个整数的每一位数字的汉语拼音，每一位数字的拼音之间以空格分隔，末尾没有空格。
>
> **输入样例：**
>
> -30
>
> **输出样例：**
>
> fu san ling



### 第六章：数组与函数

#### 1.数组

**初试数组**

**定义数组**

**课后讨论6.1.1：字符可以做下标吗？**

> 数组的下标必须是整数，那么字符可以做下标吗？比如：
>
> ```c
> int a[255]; 
> a['A'] = 1;
> ```
>
> 这样的代码可行吗？为什么？

解答：

​		可以，因为字符串会被识别为ASCII码对应的数字，这些数字都是整数所以可以做下标，以下为示例：

```c
#include <stdio.h> 
int main()
{ 
    int a[255]; 
    a['A']=1; 
    printf("a['A']=%d\t'A'=%d\n", a['A'], 'A'); return 0; 
}
```

**用数组做散列计算**

#### 2.函数的定义与使用

**初见函数**

**课后讨论6.2.1：为什么要用函数？**

> 写了函数有什么好处？有没有什么亲身感受能体会到函数的好、函数的美？

答：

​		①.将代码划分为较小的功能块，每个功能块由一个函数实现，使得代码更易于理解和维护。每个函数都可以看作是一个独立的模块，这有助于提高代码的模块化程度。

​		②.函数允许将一段代码抽象为一个可重用的单元。如果需要在程序的不同部分执行相似的操作，可以调用同一个函数，减少了代码的冗余。

​		③.将功能划分为函数使得单元测试更加容易。可以独立测试每个函数，确保其行为符合预期，从而提高代码的可靠性		

​		④.通过将代码分解成小的、可管理的部分，整体的复杂性得以降低。这使得调试和修改代码更为容易。

​		⑤.在团队中工作时，使用自定义函数可以促进分工合作。每个团队成员可以负责实现和测试特定的功能，而不会过于依赖其他部分的具体实现。

**函数的定义和使用**

**从函数中返回**

#### 3.函数的参量和变量

**函数原型**

**参数传递**

**本地变量**

**杂事**

#### 4.二维数组

**二维数组**

**课后讨论6.4.1：如何用一个两重循环实现行和列的检查？**

> 视频中所说的用一个两重循环实现行和列的检查该怎么做？

答：

​		将循环中判断行列的`i`和`j`调换位置，即`board[i][j]`判断行，`board[j][i]`判断列，在遍历的同时一起进行判断即可；

```c
#include <stdio.h>
int main()
{
	const int size = 3;
	int board[size][size];
	int i, j;
	int numOfX,numOfXX;
	int numOfO,numOfOO;
	int result =-1;        //  -1:没人赢，1：X赢，0:0赢；
	
	for(i=0; i<size; i++){
		for(j=0; j<size; j++){
			scanf("%d", &board[i][j]);
		}
	} 
	for(i=0; i<size && result == -1; i++){
		numOfO = numOfX=0;
		for(j=0; j<size; j++){
			if(board[i][j]==1){
				numOfX++; 
			}else if(board[i][j]==0){ 
				numOfO++;
			}
			if(board[j][i]==1){
				numOfXX++;
			}else if(board[j][i]==0){
				numOfOO++;
			}
		} 
	}
	if(numOfO == size || numOfOO == size){
		result = 0;
	}else if(numOfX == size || numOfXX == size){
		result = 1;
	}
	
	return 0;
}
```

**章末习题：高精度小数（10分）**

> **题目内容：**
>
> 由于计算机内部表达方式的限制，浮点运算都有精度问题，为了得到高精度的计算结果，就需要自己设计实现方法。
>
> (0,1)之间的任何浮点数都可以表达为两个正整数的商，为了表达这样两个数的商，可以将相除的结果以多个整数来表示，每个整数表示结果的一位。即商的第一位用一个整数来表示，第二位用另一个整数来表示，以此类推，就可以输出一个高精度的除法结果了。
>
> 如16/19的结果0.8421052631...就可以依次输出8、4、2、1、0、5、2、6、3、1...。
>
> 而除法的过程，则可以模仿人工列竖式做除法的方式，先将被除数乘以10，得到一位商以后，将余数乘以10作为下一轮计算的被除数：
>
>   160/19->8余8
>
>   80/19->4余4
>
>   ...
>
> 当某次余数为0时，则表明除尽。
>
> 现在，请写一个程序，输入一个分数，计算出它的小数形式。无论是否可以除尽，输出最多小数点后200位。
>
> **输入格式:**
>
> 形如
>
>  		a/b
>
> 的两个数，其中10<=a<b<100。也就是说，这个小数一定是小于1的正数。
>
> 提示：输入是带着两个数中间的“/”的，所以scanf应采用“%d/%d”这样的输入格式。
>
> **输出格式：**
>
> 形如
>
> ​		0.xxxxxxxxx
>
> 的小数，小数点后最多200位。输出结束的时候要带着回车换行。如果a/b是一个有限不循环小数，则输出完所有的有效位就可以了，不需要再输出后面的0来凑满200位。
>
> **输入样例：**
>
> 16/19
>
> **输出样例：**
>
> 0.84210526315789473684210526315789473684210526315789473684210526315789473684210526315789473684210526315789473684210526315789473684210526315789473684210526315789473684210526315789473684210526315789473684

解答：

```c

```



### 第七章：数组运算

#### 1.数组运算

**数组运算**

**数组例子：素数**

#### 2.搜索

**线性搜索**

**搜索的例子**

**二分搜索**

#### 3.排序初步

**选择排序**

**章末习题：多项式加法（5分）**

> **题目内容：**
>
> 一个多项式可以表达为x的各次幂与系数乘积的和，比如：
>
> 2x6+3x5+12x3+6x+20
>
> 现在，你的程序要读入两个多项式，然后输出这两个多项式的和，也就是把对应的幂上的系数相加然后输出。
>
> 程序要处理的幂最大为100。
>
> **输入格式:**
>
> 总共要输入两个多项式，每个多项式的输入格式如下：
>
> 每行输入两个数字，第一个表示幂次，第二个表示该幂次的系数，所有的系数都是整数。第一行一定是最高幂，最后一行一定是0次幂。
>
> 注意第一行和最后一行之间不一定按照幂次降低顺序排列；如果某个幂次的系数为0，就不出现在输入数据中了；0次幂的系数为0时还是会出现在输入数据中。
>
> **输出格式：**
>
> 从最高幂开始依次降到0幂，如：
>
> 2x6+3x5+12x3-6x+20
>
> 注意其中的x是小写字母x，而且所有的符号之间都没有空格，如果某个幂的系数为0则不需要有那项。
>
> **输入样例：**
>
> 6 2
>
> 5 3
>
> 3 12
>
> 1 6
>
> 0 20
>
> 6 2
>
> 5 3
>
> 2 12
>
> 1 6
>
> 0 20
>
> **输出样例：**
>
> 4x6+6x5+12x3+12x2+12x+40

解答：

```c

```

**章末习题：鞍点（5分）**

> **题目内容：**
>
> 给定一个n*n矩阵A。矩阵A的鞍点是一个位置（i，j），在该位置上的元素是第i行上的最大数，第j列上的最小数。一个矩阵A也可能没有鞍点。
>
> 你的任务是找出A的鞍点。
>
> **输入格式:**
>
> 输入的第1行是一个正整数n, （1<=n<=100），然后有n行，每一行有n个整数，同一行上两个整数之间有一个或多个空格。
>
> **输出格式：**
>
> 对输入的矩阵，如果找到鞍点，就输出其下标。下标为两个数字，第一个数字是行号，第二个数字是列号，均从0开始计数。
>
> 如果找不到，就输出
>
> NO
>
> 题目所给的数据保证了不会出现多个鞍点。
>
> **输入样例：**
>
> 4 
>
> 1 7 4 1 
>
> 4 8 3 6 
>
> 1 6 1 2 
>
> 0 7 8 9
>
> **输出样例：**
>
> 2 1

解答：

```c

```



### 第八章：指针与字符串

#### 1.指针

**取地址运算：&运算符取得变量的地址**

**指针：指针变量就是记录地址的变量**

**指针与数组：为什么数组传进函数后的sizeof不对了**

**课后讨论8.1.1：数组变量和指针的关系**

> 老师说数组变量可以被看作是const的指针变量，到底是“**可以被看作**”，还是“**就是**”指针呢？
>
> 用程序证据（而不是搜索教科书）来说明你的观点。
>
> （提示：如果对const指针的所有的操作都可以对数组变量做，而且结果一致，就说明数组变量就是指针；如果有某个操作不能做，或者结果不一致，就说明不是指针）

解答：

​		数组变量不等于const指针变量 ， 在使用sizeof进行返回大小时使用数组变量和使用const指针变量返回的大小是不同的。可以看到在下述的代码中，我声明了一个数组arr_1它可以保存10个int类型的元素 ， 而下面我使用函数malloc开辟了一段内存空间同样可以保存10个int类型的元素，然后我使用一个const指针指向该内存空间 ， 最后我使用sizeof返回空间的大小 ， 此时可以发现只有数组变量可以成功返回空间的大小 ， 而使用const指针只是返回了指针的大小，所以数组变量并不完全等于const类型的指针，只是在某些情况下我们可以将数组变量暂时看做是一个const指针变量方便我们的理解

```c
#include<stdio.h>
#include<stdlib.h>
#define ARRLEN 10

int main()
{
    int arr_1[ARRLEN];
    int* const p = (int*)malloc(sizeof(int) * ARRLEN);
    
    printf("arr_1 size：%zd\n", sizeof(arr_1));
    printf("p size: %zd\n", sizeof(p));
    free(p);
        
    return 0;
}
```



#### 2.字符类型

**字符类型**

**逃逸字符**

#### 3.字符串

**字符串**

**字符串变量**

#### 4.字符串计算

**字符串输入输出**

**字符串函数**

**章末习题：单词长度（4分）**

> **题目内容：**
>
> 你的程序要读入一行文本，其中以空格分隔为若干个单词，以‘.’结束。你要输出这行文本中每个单词的长度。这里的单词与语言无关，可以包括各种符号，比如“it's”算一个单词，长度为4。注意，行中可能出现连续的空格。
>
> **输入格式:**
>
> 输入在一行中给出一行文本，以‘.’结束，结尾的句号不能计算在最后一个单词的长度内。
>
> **输出格式：**
>
> 在一行中输出这行文本对应的单词的长度，每个长度之间以空格隔开，行末没有最后的空格。
>
> **输入样例：**
>
> It's great to see you here.
>
> **输出样例：**
>
> 4 5 2 3 3 4

解答：

```c


```

**章末习题：GPS数据处理（6分）**

> **题目内容：**
>
> NMEA-0183协议是为了在不同的GPS（全球定位系统）导航设备中建立统一的BTCM（海事无线电技术委员会）标准，由美国国家海洋电子协会（NMEA-The National Marine Electronics Associa-tion）制定的一套通讯协议。GPS接收机根据NMEA-0183协议的标准规范，将位置、速度等信息通过串口传送到PC机、PDA等设备。
>
> NMEA-0183协议是GPS接收机应当遵守的标准协议，也是目前GPS接收机上使用最广泛的协议，大多数常见的GPS接收机、GPS数据处理软件、导航软件都遵守或者至少兼容这个协议。
>
> NMEA-0183协议定义的语句非常多，但是常用的或者说兼容性最广的语句只有`$GPGGA`、`$GPGSA`、`$GPGSV`、`$GPRMC`、`$GPVTG`、`$GPGLL`等。
>
> 其中`$GPRMC`语句的格式如下：
>
>   `$GPRMC`,024813.640,A,3158.4608,N,11848.3737,E,10.05,324.27,150706,,,A*50
>
> 这里整条语句是一个文本行，行中以逗号“,”隔开各个字段，每个字段的大小（长度）不一，这里的示例只是一种可能，并不能认为字段的大小就如上述例句一样。
>
>   字段0：`$GPRMC`，语句ID，表明该语句为Recommended Minimum Specific GPS/TRANSIT Data（RMC）推荐最小定位信息
>
>   字段1：UTC时间，hhmmss.sss格式
>
>   字段2：状态，A=定位，V=未定位
>
>   字段3：纬度ddmm.mmmm，度分格式（前导位数不足则补0）
>
>   字段4：纬度N（北纬）或S（南纬）
>
>   字段5：经度dddmm.mmmm，度分格式（前导位数不足则补0）
>
>   字段6：经度E（东经）或W（西经）
>
>   字段7：速度，节，Knots
>
>   字段8：方位角，度
>
>   字段9：UTC日期，DDMMYY格式
>
>   字段10：磁偏角，（000 - 180）度（前导位数不足则补0）
>
>   字段11：磁偏角方向，E=东W=西
>
>   字段16：校验值
>
> 这里，“`*`”为校验和识别符，其后面的两位数为校验和，代表了“`$`”和“`*`”之间所有字符（不包括这两个字符）的异或值的十六进制值。上面这条例句的校验和是十六进制的50，也就是十进制的80。
>
> 提示：`^`运算符的作用是异或。将`$`和`*`之间所有的字符做`^`运算(第一个字符和第二个字符异或，结果再和第三个字符异或，依此类推)之后的值对65536取余后的结果，应该和*后面的两个十六进制数字的值相等，否则的话说明这条语句在传输中发生了错误。注意这个十六进制值中是会出现A-F的大写字母的。
>
> 现在，你的程序要读入一系列GPS输出，其中包含`$GPRMC`，也包含其他语句。在数据的最后，有一行单独的
>
>   END
>
> 表示数据的结束。
>
> 你的程序要从中找出`$GPRMC`语句，计算校验和，找出其中校验正确，并且字段2表示已定位的语句，从中计算出时间，换算成北京时间。一次数据中会包含多条`$GPRMC`语句，以最后一条语句得到的北京时间作为结果输出。
>
> 你的程序一定会读到一条有效的`$GPRMC`语句。
>
> **输入格式:**
>
> 多条GPS语句，每条均以回车换行结束。最后一行是END三个大写字母。
>
> **输出格式：**
>
> 6位数时间，表达为：
>
>   hh:mm:ss
>
> 其中，hh是两位数的小时，不足两位时前面补0；mm是两位数的分钟，不足两位时前面补0；ss是两位数的秒，不足两位时前面补0。
>
> **输入样例：**
>
> $GPRMC,024813.640,A,3158.4608,N,11848.3737,E,10.05,324.27,150706,,,A*50
>
> END
>
> **输出样例：**
>
> 10:48:13

解答：

```c

```



